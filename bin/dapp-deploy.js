#! /usr/bin/env node

const yargs = require('yargs')
const Web3 = require('web3')
const Q = require('q')
const fs = require('fs')

const argv = yargs
    .usage(`
Tool to use in combination with 'dapphub/dapp'.
Uses artifacts generated by "dapp build".
Deploys compiled contract(s) to an Ethereum blockchain.

Each deployed contract address is saved to a JSON data file.
Format is a hash table:
    Ethereum network ID => array of addresses

Ethereum network ID represents a unique Ethereum blockchain.
Enables deployment to multiple chains.

A frontend Dapp can determine the current Ethereum network ID.
For each contract, the Dapp can perform the necessary lookup
in the corresponding hash table of deployment addresses.
Using web3.js, only 2 data files are needed per contract:
    ./out/CONTRACTNAME.abi
    ./out/CONTRACTNAME.deployed

Usage: $0 [options]
`)
    .option('all', {
      describe: 'Deploy all contracts',
      boolean: true,
      default: true
    })
    .option('c', {
      alias: ['contract', 'whitelist'],
      describe: 'Deploy specified contract(s)',
      string: true,
      array: true
    })
    .option('x', {
      alias: ['exclude_contract', 'blacklist'],
      describe: 'Do not deploy specified contract(s)',
      string: true,
      array: true
    })
    .option('l', {
      alias: ['lib', 'library'],
      describe: 'Link specified library(s) to dependent deployment contract(s)' + "\n" + 'note: The specified libary(s) won\'t be redeployed.',
      string: true,
      array: true
    })
    .option('params', {
      describe: 'Parameter(s) to pass to contract constructor(s)' + "\n" + 'note: Addresses for previously deployed contracts (with metadata located at filepaths determined by "--output_pattern" and "--output_directory") can be referenced by passing a string parameter having the format: "{{CONTRACTNAME}}"' + "\n" + 'note: Arrays can be encoded into JSON. Arrays may contain strings that reference the address of a previously deployed contract.' + "\n" + 'note: In most situations, each contract having a constructor that accepts input parameters should be deployed individually, rather than in a batch. Please be careful.',
      array: true,
      default: []
    })
    .option('value', {
      alias: 'wei',
      describe: 'Value (wei) to pass to contract constructor(s)' + "\n" + 'note: In most situations, each contract having a payable constructor should be deployed individually, rather than in a batch. Please be careful.',
      number: true,
      default: 0
    })
    .option('gas', {
      describe: 'Gas to send with each transaction' + "\n" + 'note: In most situations, it would be better to not use this option. By default, the amount of gas sent is an estimate.',
      number: true
    })
    .option('h', {
      alias: 'host',
      describe: 'Ethereum JSON-RPC server hostname',
      string: true,
      default: 'localhost'
    })
    .option('p', {
      alias: 'port',
      describe: 'Ethereum JSON-RPC server port number',
      number: true,
      default: 8545
    })
    .option('tls', {
      alias: ['https', 'ssl'],
      describe: 'Require TLS handshake (https:) to connect to Ethereum JSON-RPC server',
      boolean: true,
      default: false
    })
    .option('a', {
      alias: ['aa', 'account_address'],
      describe: 'Address of Ethereum account to own deployed contracts',
      string: true,
      nargs: 1
    })
    .option('A', {
      alias: ['ai', 'account_index'],
      describe: 'Index of Ethereum account to own deployed contracts.' + "\n" + 'note: List of available/unlocked accounts is determined by Ethereum client.',
      number: true,
      nargs: 1,
      default: 0
    })
    .option('i', {
      alias: 'input_directory',
      describe: 'Path to input directory. All compiled contract artifacts are read from this directory.' + "\n" + 'note: The default path assumes that the current directory is the root of a compiled "dapp" project.',
      string: true,
      nargs: 1,
      default: './out'
    })
    .option('o', {
      alias: ['od', 'output_directory'],
      describe: 'Path to output directory. All "CONTRACTNAME.deployed" JSON files will be written to this directory.',
      string: true,
      nargs: 1,
      default: './out'
    })
    .option('O', {
      alias: ['op', 'output_pattern'],
      describe: 'Pattern to specify absolute output file path. The substitution pattern "{{contract}}" will be interpolated.' + "\n" + 'note: The substitution pattern is required.',
      string: true,
      nargs: 1
    })
    .option('v', {
      alias: 'verbose',
      describe: 'Configure how much information is logged to the console during the deployment of contracts.',
      count: true
    })
    .option('q', {
      alias: 'quiet',
      describe: 'Disable log messages. Output is restricted to the address(es) of newly deployed contracts. If a single contract is specified, returns a string. Otherwise, returns a hash (name => address) in JSON format. This data can be piped to other applications.',
      boolean: true,
      default: false
    })
    .example('$0', 'deploy all contracts via: "http://localhost:8545" using account index #0')
    .example('$0 -A 1', 'deploy all contracts via: "http://localhost:8545" using account index #1')
    .example('$0 -h "mainnet.infura.io" -p 443 --ssl -a "0xB9903E9360E4534C737b33F8a6Fef667D5405A40"', 'deploy all contracts via: "https://mainnet.infura.io:443" using account address "0xB9903E9360E4534C737b33F8a6Fef667D5405A40"')
    .example('$0 -c Foo', 'deploy contract: "Foo"')
    .example('$0 -x Foo', 'deploy all contracts except: "Foo"')
    .example('$0 -c Foo --params bar baz 123 --value 100', 'deploy contract: "Foo"' + "\n" + 'call: "Foo(\'bar\', \'baz\', 123)"' + "\n" + 'pay to contract: "100 wei"')
    .example('$0 -c Foo --params \'["a","b","c"]\'', 'deploy contract: "Foo"' + "\n" + 'call: "Foo([\'a\', \'b\', \'c\'])"')
    .example('$0 -c Foo --params \'[1,2,3]\'', 'deploy contract: "Foo"' + "\n" + 'call: "Foo([1, 2, 3])"')
    .example('$0 -c Foo --params \'{{Bar}}\' \'{{Baz}}\' \'["{{Bar}}","{{Baz}}"]\'', 'deploy contract: "Foo"' + "\n" + 'call: "Foo(\'0x123\', \'0x456\', [\'0x123\', \'0x456\'])"' + "\n" + 'where:' + "\n  - " + 'contract "Bar" is deployed to address "0x123" with metadata at: "./out/Bar.deployed"' + "\n  - " + 'contract "Baz" is deployed to address "0x456" with metadata at: "./out/Baz.deployed"')
    .example('$0 -c Foo -l Bar=0x12345 Baz=0x98765', 'deploy contract: "Foo"' + "\n" + 'link to libraries: "Bar" at address: "0x12345", "Baz" at address: "0x98765"')
    .example('$0 -c Foo Bar Baz', 'deploy contracts: ["Foo","Bar","Baz"]')
    .example('$0 -c Foo -o "~/Dapp_frontend/contracts"', 'generate: "~/Dapp_frontend/contracts/Foo.deployed"')
    .example('$0 -c Foo -O "~/Dapp_frontend/contracts/{{contract}}.deployed.json"', 'generate: "~/Dapp_frontend/contracts/Foo.deployed.json"')
    .example('$0 -c Foo -i "~/Dapp_contracts/out" -O "./contracts/{{contract}}.deployed.json"', 'deploy contract: "~/Dapp_contracts/out/Foo.bin"' + "\n" + 'and generate: "./contracts/Foo.deployed.json"')
    .help('help')
    .wrap(yargs.terminalWidth())
    .epilog("copyright: Warren Bank <github.com/warren-bank>\nlicense: GPLv2")
    .argv

const contract_whitelist = argv.c
const contract_blacklist = argv.x
const contract_libraries = argv.l

const https = argv.tls
const host = argv.h
const port = argv.p

var params = argv.params.map((param) => {
  if (
    (typeof param === 'string') &&
    (param[0] === '[') &&
    (param[param.length - 1] === ']')
  ){
    // JSON-encoded array
    try {
      param = JSON.parse(param)
    }
    catch(e){}
  }
  return param
})
const wei = argv.wei
const gas = argv.gas

const account_address = argv.aa
const account_index = argv.ai

const input_directory = argv.i
const output_directory = argv.od
const output_pattern = argv.op

const QUIET = argv.q
const VERBOSE_LEVEL = QUIET ? -1 : argv.v
const PIPE  = function() { VERBOSE_LEVEL <  0 && process.stdout.write.apply(process.stdout, arguments) }
const WARN  = function() { VERBOSE_LEVEL >= 0 && console.log.apply(console, arguments) }
const INFO  = function() { VERBOSE_LEVEL >= 1 && console.log.apply(console, arguments) }
const DEBUG = function() { VERBOSE_LEVEL >= 2 && console.log.apply(console, arguments) }

var regex, keys

const preprocess_params = function(network_id){
  var dependent_contracts = {}  // name => address
  var missing_dependencies = {}  // name => bad_filepath
  var contract_name

  regex = /^\{\{([^\}]+)\}\}$/
  var extract_contract_name_from_param = function(param){
    if (Array.isArray(param)){
      param.forEach(extract_contract_name_from_param)
    }
    else if (typeof param === 'string') {
      if (param.match(regex)) {
        contract_name = param.replace(regex, '$1')
        dependent_contracts[contract_name] = null
      }
    }
    else {}
  }
  extract_contract_name_from_param(params)

  keys = Object.keys(dependent_contracts)
  if (keys.length === 0) return

  var resolve_dependent_contracts = function(){
    var deployments_filepath, fcontent, address

    var resolve_deployment_filepath = function(contract_name){
      var stats

      if (output_pattern){
        deployments_filepath = output_pattern.replace(/\{\{contract\}\}/, contract_name)
      }
      else {
        deployments_filepath = output_directory + '/' + contract_name + '.deployed'
      }

      try {
        stats = fs.statSync(deployments_filepath)
        if (! stats.isFile()) throw ''
      }
      catch(error){
        missing_dependencies[contract_name] = deployments_filepath
        deployments_filepath = null
      }
    }

    keys.forEach((contract_name) => {
      resolve_deployment_filepath(contract_name)

      if (deployments_filepath){
        try {
          fcontent = fs.readFileSync(deployments_filepath).toString()
          fcontent = JSON.parse(fcontent)
          if (
            (fcontent) &&
            (fcontent[network_id]) &&
            (fcontent[network_id].length)
          ){
            address = fcontent[network_id][fcontent[network_id].length - 1]
            dependent_contracts[contract_name] = address
          }
          else {
            missing_dependencies[contract_name] = deployments_filepath
          }
        }
        catch(error){
          missing_dependencies[contract_name] = deployments_filepath
        }
      }
      else {}
    })
  }
  resolve_dependent_contracts()

  keys = Object.keys(missing_dependencies)
  if (keys.length){
    throw new Error('[Error] --params reference the following unresolved contracts:' + "\n  " + keys.join("\n  ") + "\n" + 'Search paths for deployment metadata:' + "\n  " + Object.values(missing_dependencies).join("\n  "))
  }

  var interpolate_contract_name_in_param = function(param){
    if (Array.isArray(param)){
      param.forEach((_param, index) => {
        param[index] = interpolate_contract_name_in_param(_param)
      })
      return param
    }
    else if (typeof param === 'string') {
      if (param.match(regex)) {
        contract_name = param.replace(regex, '$1')
        param = (dependent_contracts[contract_name])? (dependent_contracts[contract_name]) : param
        return param
      }
    }
    else {
      return param
    }
  }
  params = interpolate_contract_name_in_param(params)
}

const ls = function(path, file_ext){
  var files
  file_ext = file_ext.replace(/^\.*(.*)$/, '$1')
  regex = new RegExp('\.' + file_ext + '$')
  files = fs.readdirSync(path)
  files = files.filter((file) => {
    return file.match(regex)
  })
  return files
}

var libs, bins, abis
try {
  libs = {}  // name => address
  regex = /=(?:0x)?/
  contract_libraries && contract_libraries.forEach((lib) => {
    // lib == 'Foo=0x12345'
    var name, addr
    [name, addr] = lib.split(regex, 2)
    if (name && addr){
      libs[name] = addr
    }
  })

  bins = ls(input_directory, '.bin')
  abis = ls(input_directory, '.abi')
}
catch(error){
  WARN(error.message)
  WARN("\n")
  process.exit(1)
}

// verify each .bin has a corresponding .abi
regex = /\.bin$/
bins = bins.filter((bin) => {
  var abi = bin.replace(regex, '.abi')
  return (abis.indexOf(abi) >= 0)
})

// ignore contracts NOT in whitelist
if (contract_whitelist && contract_whitelist.length){
  regex = new RegExp('(?:^|/)(?:' + contract_whitelist.join('|') + ')\.bin$')
  bins = bins.filter((bin) => {
    return bin.match(regex)
  })
}

// ignore contracts in blacklist
if (contract_blacklist && contract_blacklist.length){
  regex = new RegExp('(?:^|/)(?:' + contract_blacklist.join('|') + ')\.bin$')
  bins = bins.filter((bin) => {
    return (! bin.match(regex))
  })
}

// ignore externally linked libraries
keys = libs && Object.keys(libs)
if (libs && keys.length){
  regex = new RegExp('(?:^|/)(?:' + keys.join('|') + ')\.bin$')
  bins = bins.filter((bin) => {
    return (! bin.match(regex))
  })
}

var web3, network_id, owner

var deployed = {}  // name => address
var awaiting_libs = {}  // name => {bin, abi, libs:[]}

Q.fcall(function () {
  web3 = new Web3(new Web3.providers.HttpProvider('http' + (https? 's' : '') + '://' + host + ':' + port))

  if (! web3.isConnected){
    throw new Error('[Error] Unable to connect to Ethereum client')
  }

  network_id = web3.version.network

  var accounts
  if (account_address){
    owner = account_address
  }
  else {
    accounts = web3.eth.accounts

    if (accounts.length === 0){
      throw new Error('[Error] The Ethereum client cannot access any unlocked accounts')
    }

    if (account_index >= accounts.length){
      throw new Error('[Error] The Ethereum client can only access ' + accounts.length + ' unlocked accounts, which are indexed #0..' + (accounts.length-1) + '. The specified index #' + account_index + ' is out-of-bounds.')
    }

    if (account_index < 0){
      throw new Error('[Error] The specified index #' + account_index + ' is invalid')
    }

    owner = accounts[account_index]
  }

  preprocess_params(network_id)
})
.then(() => {
  var regex  // locally scoped
  var promises = []

  regex = /\.bin$/
  bins.forEach((bin) => {
    var contract_name = bin.replace(regex, '')
    promises.push(deploy_contract(contract_name))
  })

  return Q.all(promises)
})
.then(() => {
  return retry_deploy_linked_contracts()
})
.catch((error) => {
  WARN(error.message)
  WARN("\n")
  process.exit(1)
})
.then(() => {
  var piped_result

  keys = Object.keys(deployed)

  if (QUIET){
    if (keys.length === 1){
      piped_result = deployed[keys[0]]
      PIPE(piped_result)
    }
    else {
      piped_result = JSON.stringify(deployed)
      PIPE(piped_result)
    }
  }

  WARN("\n")
  process.exit(0)
})

function deploy_contract (contract_name, retry){
  var keys  // locally scoped
  var bin_filepath, abi_filepath, contract_bin, contract_abi, linked_libs, linked_libs_pattern, linked_libs_match, linked_lib_name, index, known_libs, unknown_libs, $contract, gas_estimate, contract_constructor_parameters, contract_data, deployed_contract_address, promise
  var deferred = Q.defer()

  if (retry){
    contract_bin = retry.bin
    contract_abi = retry.abi
  }
  else {
    bin_filepath = input_directory + '/' + contract_name + '.bin'
    abi_filepath = input_directory + '/' + contract_name + '.abi'

    contract_bin = fs.readFileSync(bin_filepath).toString()
    contract_abi = fs.readFileSync(abi_filepath).toString()
  }

  if (retry){
    linked_libs = retry.libs
  }
  else {
    linked_libs = {}
    // Allow contract names to contain '_' character, but sequences of 2 or more in a row (ie: '__') will escape the capture pattern.
    // This regex will interpret such a sequence to mark the (premature) end of a "__path/to/contract.sol:contractName__" token.
    linked_libs_pattern = /_+((?:[^_]+(?:_[^_])?)+)_+/g
    while ((linked_libs_match = linked_libs_pattern.exec(contract_bin)) !== null) {
      if (
        (linked_libs_match[0].length === 40) &&
        (typeof linked_libs[linked_libs_match[1]] === 'undefined')
      ){
        linked_lib_name = linked_libs_match[1]
        // sanitize name
        index = linked_lib_name.indexOf(':')
        if (index >= 0){
          linked_lib_name = linked_lib_name.substr(index + 1)
        }
        else {
          // path to contract.sol (?)
          linked_lib_name = linked_lib_name.replace(/^[\/]?(?:[^\/]+[\/])*([^\/]+)\.sol$/, '$1')
        }
        linked_libs[linked_lib_name] = new RegExp(linked_libs_match[0], 'g')
      }
    }
  }

  keys = linked_libs && Object.keys(linked_libs)
  if (linked_libs && keys.length){
    known_libs = Object.assign({}, libs, deployed)  // name => address

    unknown_libs = []
    keys.forEach((lib) => {
      if (typeof known_libs[lib] === 'undefined') {
        unknown_libs.push(lib)
      }
      else {
        contract_bin = contract_bin.replace(linked_libs[lib], known_libs[lib].replace(/^(0x)?/, ''))
        delete linked_libs[lib]
      }
    })

    if (unknown_libs.length){
      awaiting_libs[contract_name] = {
        bin: contract_bin,
        abi: contract_abi,
        libs: linked_libs
      }
      if (! retry){
        DEBUG('[Notice] "' + contract_name + '" contract needs linking to the following library(s):' + "\n  " + unknown_libs.join("\n  ") + "\n" + 'Will resume when their deployed addresses become available.')
      }
      deferred.resolve()
      return deferred.promise
    }
  }

  $contract = web3.eth.contract(JSON.parse(contract_abi))

  if (gas){
    gas_estimate = gas
  }
  else if (params.length === 0) {
    try {
      gas_estimate = web3.eth.estimateGas({data: contract_bin})
    }
    catch(error){
      deferred.reject(new Error('[Error] Deployment of "' + contract_name + '" contract failed with the following information:' + "\n" + error.message))
      return deferred.promise
    }
  }
  else {
    try {
      contract_constructor_parameters = params.slice()
      contract_constructor_parameters.push({data: contract_bin})
      contract_data = $contract.new.getData.apply($contract, contract_constructor_parameters)
      gas_estimate = web3.eth.estimateGas({data: contract_data})
    }
    catch(error){
      deferred.reject(new Error('[Error] Deployment of "' + contract_name + '" contract failed with the following information:' + "\n" + error.message))
      return deferred.promise
    }
  }

  contract_constructor_parameters = (params.length)? params.slice() : []
  contract_constructor_parameters.push({
    data: contract_bin,
    from: owner,
    gas: gas_estimate,
    value: wei
  })
  contract_constructor_parameters.push((error, deployed_contract) => {
    if (error){
      return deferred.reject(new Error('[Error] Deployment of "' + contract_name + '" contract failed with the following information:' + "\n" + error.message + "\n\n" + 'The constructor was passed the following parameters:' + "\n" + JSON.stringify(contract_constructor_parameters.slice(0,-1))))
    }
    if (! deployed_contract) {
      return deferred.reject(new Error('[Error] Deployment of "' + contract_name + '" contract failed with no additional information.' + "\n" + 'The constructor was passed the following parameters:' + "\n" + JSON.stringify(contract_constructor_parameters.slice(0,-1))))
    }
    if (! deployed_contract.address) {
      DEBUG('[Notice] Transaction hash for deployment of "' + contract_name + '" contract:' + "\n    " + deployed_contract.transactionHash)
    }
    else {
      deployed_contract_address = deployed_contract.address

      deployed[contract_name] = deployed_contract_address
      if (retry) delete awaiting_libs[contract_name]

      INFO('[Notice] "' + contract_name + '" contract has successfully been deployed at address:' + "\n    " + deployed_contract_address)
      deferred.resolve()
    }
  })

  $contract.new.apply($contract, contract_constructor_parameters)

  promise = deferred.promise
  .then(() => {
    return save_deployment_address(contract_name, deployed_contract_address)
  })

  return promise
}

function save_deployment_address(contract_name, deployed_contract_address){
  var deployments_filepath, contract_deployments, file_exists, promise
  var deferred = Q.defer()

  if (output_pattern){
    deployments_filepath = output_pattern.replace(/\{\{contract\}\}/, contract_name)
  }
  else {
    deployments_filepath = output_directory + '/' + contract_name + '.deployed'
  }

  fs.stat(deployments_filepath, (error, stats) => {
    file_exists = (!error && stats.isFile())
    deferred.resolve()
  })

  promise = deferred.promise
  .then(() => {
    if (file_exists){
      try {
        contract_deployments = fs.readFileSync(deployments_filepath).toString()
      }
      catch (error){
        throw new Error('[Error] Reading of file "' + deployments_filepath + '" failed with the following information:' + "\n" + error.message)
      }
      try {
        contract_deployments = JSON.parse( contract_deployments )
      }
      catch (error){
        throw new Error('[Error] Parsing of JSON data in "' + deployments_filepath + '" failed with the following information:' + "\n" + error.message)
      }
    }
    else {
      contract_deployments = {}
    }

    if (typeof contract_deployments[network_id] === 'undefined'){
      contract_deployments[network_id] = []
    }
    contract_deployments[network_id].push(deployed_contract_address)

    try {
      fs.writeFileSync(deployments_filepath, JSON.stringify(contract_deployments))
      WARN('[Notice] Address of deployed "' + contract_name + '" contract has successfully been added to file:' + "\n    " + deployments_filepath)
    }
    catch (error){
      throw new Error('[Error] Unable to output address of deployed "' + contract_name + '" contract to file "' + deployments_filepath + '". Operation failed with the following information:' + "\n" + error.message)
    }
  })

  return promise
}

function retry_deploy_linked_contracts(_deferred){
  var keys  // locally scoped
  var start_count, promises, end_count
  var deferred = _deferred || Q.defer()

  keys = Object.keys(awaiting_libs)
  start_count = keys.length

  if (start_count === 0){
    deferred.resolve()
    return deferred.promise
  }

  promises = []

  keys.forEach((contract_name) => {
    var retry = awaiting_libs[contract_name]
    promises.push(deploy_contract (contract_name, retry))
  })

  Q.all(promises)
  .then(() => {
    keys = Object.keys(awaiting_libs)
    end_count = keys.length

    if (end_count === 0){
      deferred.resolve()
    }
    else if (end_count === start_count){
      deferred.reject(new Error('[Error] Deployment of the following contracts failed due to dependency upon unlinked library(s):' + "\n" + JSON.stringify(awaiting_libs)))
    }
    else {
      // recursion: this call made some progress. try again..
      retry_deploy_linked_contracts(deferred)
    }
  })
  .catch((error) => {
    deferred.reject(error)
  })

  return deferred.promise
}
